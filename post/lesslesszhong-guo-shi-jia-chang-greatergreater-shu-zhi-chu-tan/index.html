<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>《中国式家长》数值初探 | Gamer的个人博客</title>
<link rel="shortcut icon" href="https://liam11811.github.io/favicon.ico?v=1665749981801">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://liam11811.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="《中国式家长》数值初探 | Gamer的个人博客 - Atom Feed" href="https://liam11811.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="《中国式家长》是一款聚焦中国未成年人亲子互动、社交关系以及成长路径、职业选择的模拟养成游戏。本游戏的主角、“中国式家长”的子女需要提升各项属性、学习各类课程并经由一系列自主抉择和随机事件走向游戏的终局——高考、就业和传承后代。
零、数值和基..." />
    <meta name="keywords" content="模拟游戏,独立游戏,数值" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://liam11811.github.io">
  <img class="avatar" src="https://liam11811.github.io/images/avatar.png?v=1665749981801" alt="">
  </a>
  <h1 class="site-title">
    Gamer的个人博客
  </h1>
  <p class="site-description">
    记录游戏过程中的所思所想
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              《中国式家长》数值初探
            </h2>
            <div class="post-info">
              <span>
                2022-10-04
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://liam11811.github.io/tag/U5Ap5vSv2/" class="post-tag">
                  # 模拟游戏
                </a>
              
                <a href="https://liam11811.github.io/tag/LHOlT3BfyK/" class="post-tag">
                  # 独立游戏
                </a>
              
                <a href="https://liam11811.github.io/tag/GnuYaUnP0/" class="post-tag">
                  # 数值
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://liam11811.github.io/post-images/lesslesszhong-guo-shi-jia-chang-greatergreater-shu-zhi-chu-tan.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>《中国式家长》是一款聚焦中国未成年人亲子互动、社交关系以及成长路径、职业选择的模拟养成游戏。本游戏的主角、“中国式家长”的子女需要提升各项属性、学习各类课程并经由一系列自主抉择和随机事件走向游戏的终局——高考、就业和传承后代。</p>
<p><strong>零、数值和基本玩法简介</strong></p>
<p>主角拥有<strong>智商、情商、想象力、记忆力、体魄、魅力</strong>六项可见的属性，其中尤以前四项属性与语数英文理系列课程（即备考系列课程）密切相关，也是本文主要关注的数值。</p>
<p>本游戏可养育多代子女，一代子女的成长期为47个回合。每回合以“挖掘脑洞”为起点，随后处理邀约、面子比拼、班长竞选等事务，最后以做出活动安排并自动执行安排为终点。</p>
<p>其中，**“挖掘脑洞”<strong>环节占据了玩家的绝大部分操作量和大量脑力，具体玩法是玩家通过消耗一定</strong>“行动力”<strong>点击游戏界面中的“脑洞”泡泡，后者大部分是普通脑洞，能为除魅力以外五项属性之一增加一个固定值。在此环节，玩家还可以选择点击</strong>“悟性”**泡泡获得固定25点的悟性，积累起来的悟性可以被花费以学习课程、同时解锁后续课程。</p>
<p>在行动力被消耗完后，玩家可以为主角安排6项活动，可选择的活动随着主角的成长、已学课程的累计和道具的解锁而增多。<strong>安排</strong>完毕后，主角会进行以上6项活动并经历3项随机事件，它们会改变（一般是增加）玩家属性并回复行动力，以备下回合“挖掘脑洞”环节使用。整体过程如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://liam11811.github.io/post-images/1664906972764.png" alt="" loading="lazy"></figure>
<p><strong>一、从直观到具体：属性值与所需悟性值的关系</strong></p>
<p><strong>1.1</strong> <strong>在游玩过程中，笔者注意到：</strong></p>
<p>**（1）**许多课程同时依赖于两项属性，这两项属性能同等地降低悟性消耗，不存在主次之分——进一步地，<strong>四项属性均不存在主次之分</strong>。如下图，依赖于情商和体魄的“翻跟头”课程所需悟性值只由两项数值的总和决定。</p>
<figure data-type="image" tabindex="2"><img src="https://liam11811.github.io/post-images/1664906991415.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://liam11811.github.io/post-images/1664907085630.png" alt="" loading="lazy"></figure>
<p>**（2）**随着某门课程所依赖的属性提高，学习这门课程所需的悟性值从999开始下降，下降趋势先快后慢，且在悟性消耗达到最低值时不再下降。</p>
<p><strong>1.2 量化二者关系</strong></p>
<p>要精确地量化所需悟性值的下降趋势，则需要统计某门课程依赖属性值-所需悟性值的对应关系。笔者依旧以“翻跟头”课程为例，当情商和体魄两数值之和达到81时，“翻跟头”所需悟性值首次从999开始下降；当两数值之和逐渐增加到468左右时，所需悟性降至最低值20。数据参见以下图表：</p>
<figure data-type="image" tabindex="4"><img src="https://liam11811.github.io/post-images/1664907093878.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://liam11811.github.io/post-images/1664907102966.png" alt="" loading="lazy"></figure>
<p>可见，<strong>课程所依赖属性x与课程所消耗悟性y呈幂函数关系，y正比于x-2.2</strong>。</p>
<p>为排除孤例带来的偶然性，笔者再次对依赖于情商的课程“学说话”进行统计，结果如下图：</p>
<figure data-type="image" tabindex="6"><img src="https://liam11811.github.io/post-images/1664907109664.png" alt="" loading="lazy"></figure>
<p>可见，另一门课程所依赖属性x与课程所需悟性y同样呈幂函数关系。考虑到已有数值的诸多局限性<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，以及游戏制作者的一般思路，可以人为y同样正比于x-2.2。</p>
<p><strong>1.3关注临界状态</strong></p>
<p>同样基于数值局限性和反推制作者思路的考虑，<strong>为确定x-2.2的系数，笔者选择用“前/后突变点”进行计算</strong>。</p>
<p>所谓“前突变点”是x增加最小单位（游戏内为1）引起y从固定的最大值999开始下降时的x-y对应值；“后突变点”则是x增加最小单位引起y下降到固定的最低值时的x-y对应值。经试验，“学说话”的突变点是（27，925）（156，20）；“翻跟头”的突变点是（81，975）（468，20）。用一门课程的前和后突变点计算该课程x-2.2的系数所得结果差别不大，“学说话”和“翻跟头”的系数值分别为1.32×106和1.52×107。</p>
<p>同理，<strong>只要能确定任何一门课程的突变点，辅以已知的y正比于x-2.2的关系，就可以较准确地确定全部的x-y对应关系</strong>，这将在理论上极大地有助于有细化操作需求的玩家。</p>
<p><strong>突变点还能揭示游戏制作者阶梯式提高课程所需悟性值的设计思路：</strong></p>
<p>不难观察到，“翻跟头”的前后突变点x值均是“学说话”的3倍。又考虑到两门课程同在游戏早期出现，一般玩家在此时期并不会刻意追求单项属性而是全面发展，且前者依赖于两个属性而后者只依赖于一个，因此在游戏制作者的设计中，<strong>“翻跟头”的学习门槛应是“学说话”的1.5倍；换言之，“翻跟头”是比“学说话”高出半级的课程</strong>。“高半级”的设计同样在游玩过程中可以被敏锐的玩家感知到：</p>
<figure data-type="image" tabindex="7"><img src="https://liam11811.github.io/post-images/1664907118899.png" alt="" loading="lazy"></figure>
<p>如上图，在游戏的第三回合初，玩家已经可以以较低代价学习“学说话”，但是离“翻跟头”还有一步之遥。通过上述分析可知这是游戏制作者有意为之。</p>
<p><strong>二、数值成长</strong></p>
<p>前文已经介绍过，一代子女的成长期为47个回合。每回合以“挖掘脑洞”为起点，随后处理邀约、面子比拼、班长竞选等事务，最后以做出活动安排并自动执行安排为终点。数值成长既包括玩家自由选择性挖掘脑洞、学习课程、处理事件带来的<strong>回合内成长</strong>，也包括安排6种活动、经历3种随机事件并获取每回合数值加成的<strong>回合间成长</strong>。</p>
<p>经过笔者实测（如图），总体上回合内成长与回合间成长带来的数值变化并无量级上的差距，因此回合内挖掘脑洞、处理事务等操作与回合间安排并进行活动、经历随机事件是同等重要的。</p>
<figure data-type="image" tabindex="8"><img src="https://liam11811.github.io/post-images/1664907166434.png" alt="" loading="lazy"></figure>
<p><strong>2.1常规的数值成长历程</strong></p>
<p>笔者以中等加成的家族开局，以高考应试为目标，采取遵循基本玩法、符合玩家直觉的游玩方式，进行了一局游戏并对数值进行记录和分析，试图呈现本游戏最常规的数值成长历程。</p>
<p>以“智商”属性为例，第1至第47回合中智商成长的趋势从直观上看先慢后快、形似指数上升：</p>
<p><img src="https://liam11811.github.io/post-images/1664907179230.png" alt="" loading="lazy"><br>
<img src="https://liam11811.github.io/post-images/1664907195024.png" alt="" loading="lazy"></p>
<p>可是无论以指数函数、一次函数还是高次函数来拟合，效果均称不上理想。此时可以将数值成长分阶段考虑。</p>
<p><strong>2.2数值成长的阶段性</strong></p>
<p>笔者综合实际数值成长曲线和主角成长历程，将本游戏数值成长阶段分为四个：（1）学龄前5回合（2）幼儿园和小学18回合（3）初高中10回合（4）高考冲刺4回合。首尾两短暂阶段的特点尤为明显，故单列：在学龄前，备考系列课程尚未出现，已有数值相对于随机事件引起的数值变化明显偏小；在高考冲刺阶段，“黄冈密卷”等大幅提升四维属性的安排解锁，玩家的游玩逻辑也转变为积攒悟性值尽可能多学习课程。而占据大部分回合数的第二、第三阶段的主要区别在于数值成长速度和是否开放“邀约”系统，并无本质区别。</p>
<p>笔者仍以“智商”属性为例，在划分四阶段后，后三阶段属性成长呈现分段的直线形态，且拟合程度理想；第一阶段仍因前述原因难以很好拟合。</p>
<figure data-type="image" tabindex="9"><img src="https://liam11811.github.io/post-images/1664907203828.png" alt="" loading="lazy"></figure>
<p>可见，<strong>本游戏典型的数值成长历程呈现明显的分段特征</strong>：随着所处阶段向后推移，数值成长的速度加快，在核心玩法不变的基础上开放的次要玩法变多，游玩重心逐渐转移到高考冲刺。游戏制作者也不会任由数值加速膨胀，会对其施以限制，使数值大小可控且与玩法协调。</p>
<p><strong>2.3数值成长中的硬性限制：为了可控和协调<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></strong></p>
<p>游戏明确告知玩家，脑洞层数越高，单次挖掘普通脑洞获得的属性提升越多；游戏没有明确告知玩家的是，一回合能向下挖掘的脑洞层数最高为4，而且如果本层层数是4的倍数，则无法进入下一层。</p>
<p>又经计算，大约每挖掘18层脑洞能使单次挖掘普通脑洞获得的属性额外增加1。因此，在最理想的状态下，需18÷4=4.5回合才能使单次挖掘普通脑洞获得的属性增加1。考虑到游戏的随机性，这样一次成长一般需要6回合左右。而后三阶段的总回合数为42，这就确保了单次挖掘普通脑洞获得的属性会以较均匀速度从初始值4成长6次至上限10或成长7次至上限11，然而即使能成长至11，也是游戏相当晚期的数个回合了，意义不大）。</p>
<p>玩家明明具备策略和运气挖掘到下一层，却被游戏机制所阻止。这种限制看起来简单粗暴，但若完全不加以限制，总会出现超预想的高加成，它使得挖掘脑洞带来的数值成长显著高于前文所述的回合间成长，从而<strong>打破回合内成长与回合间成长的平衡</strong>。这样一来，回合间成长将沦为鸡肋，进一步使德回合间安排并进行活动、经历随机事件变得无关紧要，这是游戏内容和游戏趣味性的极大损失。因此，对单回合脑洞最大下探层数做出硬性限制是合理且简单的。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>例如，游戏内呈现的数值全部为近似后的自然数、课程所需悟性值最大仅显示为999。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>由于第一阶段的特殊性，本段内容主要关注占据游玩大部分时长的后三阶段。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://liam11811.github.io/post/tan-zhan-shi-kong-jian/">
              <h3 class="post-title">
                谈“展示空间”
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://liam11811.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
